# processingjs-es7

An attempt at an ES2017 implementation of [Processing.js](https://github.com/processing-js/processing-js), with [rollup](http://rollupjs.org/guide) as bundler.

- [x] port the parser
- [x] rewrite how sketches are run (from new Function() to `<script>` elements instead)
- [x] slot in some of the basic Processing API to get a canvas to do a thing at all
- [ ] make the parser generate ES7 code

## From source code to animation on a page

The process of conversion and interpretation runs through quite a few steps, so buckle up, here's the [entire codepath](src/Processing.js#L126-L138):

1. The source code is read either from file(s) or `script.textContent`(s)
2. The source is aggregated into one giant string
3. This string is handed off to the parser, which converts it to a javascript-implementation of a Processing AST
4. The AST is then told to serialize itself as JavaScript code
5. This leads to a skech of the following form:

```
1: // this code was autogenerated by ProcessingJS-ES7 version ${version}`
2: (function(PJS) {
3:   let $p = PJS.generateDefaultScope();
4:   $p.id = {{ SKETCH_ID_PLACEHOLDER }};
5:   // code for any classes the user defined
6:   // code for other statements the user defined
7:   PJS.onSketchLoad($p);
8: }(Processing));
```

This code is then handed back to the page in the form of a `<script>` element, injected into the `<head>` (with the `{{ SKETCH_ID_PLACEHOLDER }}` part turned into a numerical identifier), which causes the browser to run it as it would any other JavaScript. This does a few things:

 - `3: let $p = PJS.generateDefaultScope();` this calls `Processing.generateDefaultScope`, which in turn falls through to `DefaultScope.generateDefaultScope()`, which generates the bulk of the Processing API, albeit not associated with any particular sketch yet.
 - `7: PJS.onSketchLoad($p);` this calls `Processing.onSketchLoad()` with the scoping object generated above as argument. This function crosslinks the incoming sketch with some cached values it knows about from before the javascript source got injected into the page, and then wraps the sketch in a [`SketchRunner`](src/SketchRunner.js) object, which is responsible for the whole "animation" thing.
 - the `SketchRunner` performs the hooking of sketch-specific API functions and constants into the generic scope object it was passed, and now we have an actually fully functioning sketch object. We just need to run it.
 - Unsurprisingly, this is the final function call in `Processing.onSketchLoad` before it returns.

## How does the DefaultScope impart Processing API aspects?

The [`DefaultScope`](src/DefaultScope.js) is literally an aggregation of everything in the Processing API that is not directly tied to the running state of a sketch. This includes things like Processing constants, Object data types like ArrayList or Hashmap, Maths functions etc. It does this in a slightly not-ES7-ish way though:

```
import PConstants from "./PConstants";
import ArrayList from "./Processing Objects/ArrayList"
...

export default function generateDefaultScope(additionalScopes) {
  let DefaultScope = function DefaultScope() {};

  DefaultScope.prototype = Object.assign(
    {},
    PConstants,
    Math,
    ...,
    {
      ArrayList,
      Char,
      ...
    }
  );

  let defaultScope = new DefaultScope();

  if (additionalScopes) {
    Object.keys(additionalScopes).forEach(prop => {
      defaultScope[prop] = scopes[prop]
    });
  }

  defaultScope.__setup_drawing_context = function(canvas, context) {
    defaultScope.context = new Drawing2D(defaultScope, canvas, context);
  }

  // ...lots of parser-related code

  return defaultScope;
}
```

The prototype assignment turns the defaultScope's prototype into a massive object with properties pulled from lots of different specific-task-or-object modules, with things like ArrayList, Char, etc. tacked on wholesale (so that `p.ArrayList` is `ArrayList`, rather than copying the *content* of an ArrayList class into the defaultScope. That would be bad =).

## How does the SketchRunner impart Processing API aspects?

The sketch runner is passed an actual sketch-to-run, and so has all the information it needs to be able to tack Processing API functions into the sketch that *are* tied to the running state of the sketch. Things like drawing onto a canvas (each sketch has its own), play bindings (each sketch has their own look/noLoop/frameCount/etc.), are all imparted using functions similar to:

```
function addThingsToASketch(sketch) {
	let locallyScopedVariable = ...;

	const locallyScopedConstant = ...;

	function locallyScopedFunction(...) {
	  ...
	}

  sketch.processingFunction = function() {
    // Do things with both locally and sketch-scoped vars, consts, functions, etc.
    // As well as whatever needs to be done for this Processing function, of course.
  }

  sketch.nextProcessingFunction = function() {
    // ...
  }
}
```

So sketches are assigned their own set of functions each for these type of functions, and these type of wrappers are found in the `./src//bindings` directory. Note that any code that imparts sketch-agnostic functions should *not* be found anywhere in any source file in the bindings dir.

## How does the Drawing context impart processing API aspects?

Finally, the third way Processing API functionality is imparted is through the [`DrawingShared`](src/drawing/DrawingShared.js) class, which the concrete `Drawing2D` and `Drawing3D` classes extend. These classes are found in the `./src/drawing` directory, and of the three ways the API is imparted, is frankly the least inspiring:

```
class DrawingShared {
  // ...

  bindSketchFNames(p) {
    p.size = this.size.bind(this);
    p.background = this.background.bind(this);
    p.alpha = this.alpha.bind(this);
    ...
  }
}
```

The `DrawingShared` class houses all the drawing-related locally scoped variables (of which there are **many**), and simpy ends its constructor for a sketch by calling the `this.bindSketchFNames()` function with the active sketch as argument. function assignment is performed, using `bind(this)` to ensure that the execution context for the functions stays the Drawing class, rather than becoming the sketch, and that's it, really.


## The parser

The parser is found in [`./src/Parser/`](src/Parser) and its main entry point is transformMain() in [`./src/Parser/transform-main.js`](src/Parser/transform-main.js). This function cleans up the code that's being passed in, runs it through AST abstraction, and then spits out an AST representing the Processing code in terms of an abstract syntax tree with an [`AST` node](src/Parser/ast%20objects/ast.js) at the top.

This AST and any node in it knows how to serialize itself into JavaScript (a process which may, and does, rewrite certain code instructions to function calls into the `DefaultScope` for hooking up things in JavaScript in a way that matches the different way Java wants to do things), and so the only thing needed to convert an AST into (hopefully) working JavaScript is to call `ast.toString()`,

## This is a work in progress

This code is still in a pre-release stage, and architectural designs might still change before a final "port to ES7" is deemed done. Don't trust that any part of this codebase is stable, and don't rely on any of the approaches described above and found the code are going to still be there by the time the porting process is completed.

## Specific Licenses

The Processing.js code is licensed under the same terms as listed on [the Processing.js repository](https://github.com/processing-js/processing-js/blob/master/CONTRIBUTING.md#what-happens-with-my-contributions-will-i-get-credit)

The "Pamega" font is assumed free and was obtained via http://www.dafont.com/pamega-script.font - is this is your font and dafont violated your copyright, and you'd like me to remove this font: please let them know, and CC me on that email so that I know you take copyright seriously instead of only talking to me, not talking to the people responsible (it's crazy I have to say this, but there it is).
